# 문제 길이가 길어서 이해하는데 시간이 좀 걸린다.
# 레이저 탑의 길이가 주어지고 레이저를 쏘는데 왼쪽으로 밖에 못 쏜다고 한다.
# 왼쪽의 레이저 타워가 크면, 수신이 가능하다. 그러나 작다면 수신 불가하다.
# 무조건 왼쪽 편에는 본인보다 큰 레이저 타워가 있어야한다.
# 출력은 본인의 레이저를 받은 타워의 번호를(인덱스 아님) 출력한다.
# 그림을 그리면 이해하기 수월하다. 레이저 타워 크기가 6 9 5 7 4 이면
# 답은 0 0 2 2 4이다. 6과 9는 레이저를 못주기 때문이다.
# 1. 스택에 탑의 높이와 인덱스를 저장한다.
# 2. 현재의 탑이 스택의 top보다 크면, 스택에서 pop하고 수신 가능한 탑을 찾는다.
# 3. 스택의 top이 현재 탑보다 크면, 해당 탑이 수신한다.
# 4. 탑을 스택에 push하면서 다음 탑을 검사한다.

import sys

# 1. 입력 받기
N = int(sys.stdin.readline().strip())  # 탑 개수
heights = list(map(int, sys.stdin.readline().strip().split()))  # 탑들의 높이 인풋

# 2. 결과 저장 배열 & 스택 초기화
result = [0] * N  # 수신한 탑의 인덱스를 저장 (기본값 0)
stack = []  # (탑의 높이, 탑의 인덱스) 저장

# 3. 각 탑에 대해 왼쪽에서 수신할 수 있는 탑 찾기
for i in range(N):
    while stack and stack[-1][0] < heights[i]:    # 현재의 탑보다 작은 탑을 찾는다.(왼쪽부터 오른쪽으로)
        # stack[-1][0]인 이유는 스택안에 탑의 높이와 탑의 인덱스를 같이 저장하기 때문이다. 해당 코드는 마지막 탑의 높이를 불러오는 코드이다.
        stack.pop()  # 현재 탑보다 낮은 탑은 의미 없음 → 제거

    # 스택이 비어있지 않다면, 스택의 top이 현재 탑이 신호를 받는 탑
    if stack:
        result[i] = stack[-1][1]  # 수신한 탑의 인덱스 저장 (1-based)
        # 마지막 탑의 인덱스를 가져와서 result에 덮어 씌웁니다.

    # 현재 탑을 스택에 추가 (1-based index 사용)
    stack.append((heights[i], i + 1)) # 현재 탑을 스택에 저장합니다(높이,인덱스)
    # 인덱스는 1 ~ N이므로 i + 1을 저장합니다.

# 4. 결과 출력
print(*result)   # 리스트 대괄호를 없애고 출력합니다.

# 이론은 쉬운것 같은데 코드구현이 어려웠던 문제였던 것 같습니다.
# 솔직히 지금도 70퍼센트는 이해한것 같은데 다음에 다시 이해해보겠습니다.