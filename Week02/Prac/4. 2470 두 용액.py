# 값을 비교해서 절대값 쓰워서 제일 작은 값에 해당하는 두 용액을 뽑으면 된다.
# 하나 값을 잡고 나머지와의 차이를 비교한다. 만약 사이클 한 번 돌리면 전체적인 차를 알 수 있기 때문에
# 전체적인 차를 알 수 있지 않을까?(절대값은 씌어야한다)
# 근데, 이렇게하면 시도 횟수가 증가하여 시간 초과가 걸린다.
# 그러므로 투 포인터 알고리즘을 써야한다.
# 투포인터는 정해진 합의 조합 수를 찾는 알고리즘이다.

# n만큼 용액 값 받고 재정렬
n = int(input())
L = list(map(int, input().split()))   # 용액들의 리스트

L.sort()

left, right = 0, n-1  # 포인터 초기화
best_sum = float('inf')    # 두용액의 최적의 합을 구한다(최솟값을 찾을때 유용하다, 범위는 무한대)
best_pair = (L[left], L[right])   # 최적의 두 값

# 투 포인터를 탐색한다.
while left < right:
    current_sum = L[left] + L[right]    # 현재 합 비교
    
    # 두 용액의 차이가 더 적으면 갱신
    if abs(current_sum) < abs(best_sum):   # 두 용액의 차이를 현재와 예전값 비교해서 더 작으면
        best_sum = current_sum            # 갱신한다
        best_pair =(L[left], L[right])   # 최고의 조합 두 값이다.
        
    # 투 포인터를 이동시킨다.(조합 조사를 위해)
    # 양쪽에서 시작해서 합이 음수다? 왼쪽 기준 인덱스 0이 1로 이동해서 합을 구하고
    # 그 합이랑 전에 있던 합이랑 절댓값으로 비교해서 최적합으로 저장한다.
    # 양수일 때도 반대로 생각하면된다.
    if current_sum < 0:    # 합이 음수일시, 값을 증가시켜야함
        left += 1          # 투포인터 이론에 따라 이동
    elif current_sum > 0:  #합이 양수일시, 값을 감소시켜야함
        right -= 1         # 투포인터 이론에 따라 이동
    else:         # sum == 0이면 정답으로 즉시 종료
        break     

# 정답 출력
print(best_pair[0], best_pair[1])

# 확실히 이번 문제는 팀원분의 설명을 어제 들어서 이해가 잘되었다.
# 팀별 발표를 하는 것이 확실히 도움이 되었다. 앞으로도 적극 참여해야겠다.
# 첨엔 맨위에 말한것처럼 조합 다 보면서 차이 뽑아서 절댓값으로 min으로 차이 적은걸 뽑으면 되는게 아닌가?
# 했는데 찾아보니 그러면 연산이 복잡도 N^2로 100억이라 한다. 투 포인터를 사용하면 N log N으로 170만 연산만 하면
# 결과가 나와서 시간초과가 걸리지 않는다. 이렇게 투포인터로 구현하는 방법을 익혔다.