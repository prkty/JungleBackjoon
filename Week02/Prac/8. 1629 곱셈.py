# 팀원분의 힌트로 규칙을 찾았습니다.
# A를 B번 곱했을 때 C나누기의 나머지는 항상 같습니다.
# 또한 모듈러 연산이라고 (axb)%c = (a%c)*(a%c)%c 는 성립합니다.
# 첫번째 시도로 그냥 제곱한 수로 나누어 봤더니 overflow가 나와서 실패했다.
# 두번째 시도는 제곱을 반으로 나누어서 다시 제곱하는 것으로 바꾸어보았다.
# 세번째 시도는 GPT의 도움을 받아 수정하였다.
# pow를 사용힌 제곱 연산은 실수 연산으로 큰 수에서 오버플로우가 발생할 수 있다고한다.
# 그러므로 분할 정복을 사용한 (log B) 겁듭제곱 알고리즘을 사용해야한다고 한다.
# 큰 흐름은 제곱되는 수를 2로 나눈다. 어차피 결과는 같으니까. 근데, 홀수로 곱하면 2, 3, 5의 경우
# 답이 4로 틀린답이 나와버린다. 반례를 막기위해 B가 홀수면 A를 한번더 곱한다.
# 또다른 반례를 막기 위해 모듈러 연산을 사용한 나머지를 최종적으로 출력한다.


import sys
# import math

A, B, C = map(int,sys.stdin.readline().split())   # 인풋 받기
# A: 제곱할 수      B: 제곱횟수       C: 나눌 값

# def power(A, B):
#     if B == 1:
#         return A
    
#     return power(A, B-1) * A


# print(int((power(A,B))%C))
# 위에는 제가 세웠던 식입니다.

# 분할 정복을 사용한 거틉 제곱 재귀함수
def power(A, B, C):
    if B == 1:           # 제곱수가 1이라면(Base case)
        return A % C     # A를 C로 나눈 나머지를 내보낸다.
    
    half = power(A, B // 2, C)    # 기본적으로 B를 2로 나눈값을 A에 제곱한다. 
    half = (half * half) % C      # 모듈러 연산에 따라 다음 식이 성립합니다.
    
    if B % 2 == 0:        # B가 짝수라면 그대로 반환한다.
        return half
    else:                 # B가 홀수라면 A를 한 번 더 곱하고 %C를 적용한다.
        return (half * A) % C
    
print(power(A, B, C))    # 계산 완료된 값이 출력된다.

# 해당문제는 팀원분께서 알려주신 모듈러연산을 활용하여 풀 수 있었습니다.
# A,B,C에 들어가는 값이 크다 보니 직접 돌려보면 overflow가 일어났고 그것을 해결하기 위해
# 위와 같이 분할 정복과 반례를 방지한 방법을 사용했습니다.
# 그러나 예상치 못한 반례 방지와 전체적인 코드 구현은 GPT의 도움을 받았기 때문에 다음에 다시 복습하겠습니다.