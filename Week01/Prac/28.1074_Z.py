# 문제 이해는 쉽다. 그런데 코드 구현을 어떻게 해야할지 모르겠다.
# 2^N으로 증가하면서 저 Z 모양이 반복된다. 근데 이게 Z의 다음 위치도 큰 Z자로 지나간다.
# 다른 내용을 참고 했는데, 해당 문제는 재귀와 분할 정복으로 풀 수 있다고 한다.
# z를 반복적으로 불러오는건 재귀로 하면되고 해당 규칙이 2^n만큼 반복되니, 재귀 분할해서 처리하고 나중에 합치는 느낌이다.
# 일단 재귀 연습이라고 할 수 있게끔 재귀처리전 코드라도 가져왔다.
# def Z(N,r,c):
#     ans = 0

#     while N:
#         N -= 1

#         if r < 2**N and c < 2**N:
#             ans = ans

#         elif r < 2**N and c >= 2**N:
#             ans += 2**(2*N)
#             c -= 2**N

#         elif r >= 2**N and c < 2**N:
#             ans += 2*(2**(2*N))
#             r -= 2**N

#         elif r >= 2**N and c >= 2**N:
#             ans += 3*(2**(2*N))
#             r -= 2**N
#             c -= 2**N

#     return ans

# 해당공식을 내 힘으로 재귀형태로 바꿔볼려 했으나 실패했다. 시간도 부족해서...
def sol(N,r,c):   # 입력받은 인자가 수행하는 함수
    if N == 0:    # 기초적 상황인 N이 0인 경우에는 0을 반환하도록한다.
        return 0  
    
    # Z 순서 계산
    else:
        return 2*(r%2)+(c%2) + 4*(sol(N-1, r//2, c//2)) 
        # (r%2)와 (c%2)로 나머지를 뽑아서 현재 블록에서의 상대 위치를 구한다. (N=1 기준 0~3 사이의 값)
        # 해당 식에 2를 곱하는 이유는 이렇게 해야 행과 열에 따라 좌우상단, 좌우하단을 0~3으로 구현가능하다.
        # 2 안 곱하면 좌표값 0,1 이런식이라 0,1,2 이렇게 나온다.
        # 4배씩 증가하는 패턴을 고려하여 4 * sol(N-1, r//2, c//2) 를 추가한다
        # (N-1, r//2, c//2)에서 N-1은 블럭을 전단계로 나눴기 때문에 현재 단계 전 단계 결과를 불러오기 위함이다.
        # r//2, c//2의 //는 몫을 구하는 것으로 하위 블록에서의 위치이다.
        # 이후 4를 곱하면서 현재 우리가 존재하는 블록으로 복구시킨다.
        # N을 N-1로 축소화 시킨다음 다시 키운다고 생각하면 된다. 
        # 근데 그 안에서의 위치를 우린 모른다. 그러니까 2*(r%2)+(c%2)을 더해서 안에서의 위치 값을 추가한다.

N,r,c = map(int, input().split())  # 입력값 받기
print(sol(N,r,c))

# 엄청나게 긴 함수를 한줄로 줄인게 대단하다.
# 어떻게 이렇게 하는지... 이거 한줄로 만든사람은 노벨상 받아야되는거 아닌가 싶을 정도다.
# 한줄을 분해하고 이해하는데 한세월 걸렸다.