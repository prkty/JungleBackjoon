# 이거는 9명의 난쟁이 중에 7명의 난쟁이를 뽑아 100을 출력하면 된다.
# 그러면 7명의 난쟁이가 100인 조합을 찾으면 된다.
# 말이 쉽지 재귀함수를 사용해서 계속해서 일일이 돌려서 찾아야된다는 것인데...
# 코드로 어떻게 구현할 지 감이 도저히 잡히지 않아서 블로그 글을 참고 했다.
# 푸는 방식이 for, combinations, 재귀 함수가 있는데 재귀함수로 구현해 보겠다.

shortmen = [int(input()) for _ in range(9)]  # 난쟁이들의 값을 9개 받는다.
seven_sum = []   # 해당 리스트로 난쟁이 7명을 뽑아 합을 비교한다.


def dfs(depth, start):   # dfs 요소는 (배열, 시작 위치, 방문 정보)로 구성되어있는데, 해당 코드에는 방문 정보는 없다.)
    if depth == 7:    # 7번의 재귀를 돌렸다면 시행
        if sum(seven_sum) == 100:  # 현재 저장된 일곱난쟁이들의 합이 100이라면
            for j in sorted(seven_sum):   # 오름차순으로 정렬 후 출력
                print(j)
            exit()        ## 위 조건을 모두 만족하면 코드를 종료합니다.
        else:        # 7명을 뽑고 나서 합이 100이 아니라면 시행 위에 if과 세트
            return   # 해당 재귀를 실행하지 않고 종료 왜냐? 적합하지 않은 조합이니까
        
    for i in range(start, len(shortmen)) :  # 시작부터 9명의 난쟁이가 있으므로 9번을 반복한다.(7명 추가 과정)
        seven_sum.append(shortmen[i])   # 난쟁이들 중에서 한명을 비교 리스트에 추가한다.
        dfs(depth + 1, i + 1)   # 상단의 dfs로 가서 검사한다.
        # 다음 번 깊이(배열)은 +1로 해주고(다른 검사 세트) 인덱스는 중복되지 않기 위해 다음 인덱스를 넣어준다.
        seven_sum.pop()   
        # dfs 검사를 수행하다가 7명이 다 찼으나 합이 100이 되지 않아 리턴되었다면 난쟁이 한명을 다시 뺀다. 이후 다른 난쟁이 넣고 검증한다.
        # 해당기능이 백트래킹 역할을 수행한다. 만약 한명 빼도 100이 리턴되지 않으면 한 명 더 빼고 탐색한다.
        
dfs(0,0)   
# depth=0, start=0의 의미로 현재 선택된 난쟁이수가 0명이고 탐색을 시작할 남쟁이의 인덱스는 0번이라는 소리다.
# 이말은 곧 0번 난쟁이부터 하나씩 선택하면서 7명을 찾는 dfs를 시작하는 역할을 한다.
    
